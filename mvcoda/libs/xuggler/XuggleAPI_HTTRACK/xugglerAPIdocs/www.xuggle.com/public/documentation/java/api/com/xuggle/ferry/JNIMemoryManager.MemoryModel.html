<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>

<!-- Mirrored from www.xuggle.com/public/documentation/java/api/com/xuggle/ferry/JNIMemoryManager.MemoryModel.html by HTTrack Website Copier/3.x [XR&CO'2010], Fri, 14 Jun 2013 14:00:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<HEAD>
<!-- Generated by javadoc (build 1.5.0_22) on Mon Jul 11 07:40:26 UTC 2011 -->
<TITLE>
JNIMemoryManager.MemoryModel (xuggle-xuggler)
</TITLE>

<META NAME="keywords" CONTENT="com.xuggle.ferry.JNIMemoryManager.MemoryModel class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../javadoc.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="JNIMemoryManager.MemoryModel (xuggle-xuggler)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JNIMemoryManager.MemoryModel.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="JNIMemoryManager.html" title="class in com.xuggle.ferry"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="JNINativeFinalizer.html" title="class in com.xuggle.ferry"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index7d63.html?com/xuggle/ferry/JNIMemoryManager.MemoryModel.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JNIMemoryManager.MemoryModel.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#enum_constant_summary">ENUM CONSTANTS</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#enum_constant_detail">ENUM CONSTANTS</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.xuggle.ferry</FONT>
<BR>
Enum JNIMemoryManager.MemoryModel</H2>
<map id="G" name="G">
<area shape="rect" href="JNIMemoryManager.MemoryModel.html" title="&lt;TABLE&gt;" alt="" coords="16,11,171,64"/>
</map>
<div align="center"><img src="JNIMemoryManager.MemoryModel.png" alt="Package class diagram package JNIMemoryManager.MemoryModel" usemap="#G" border=0/></a></div>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html" title="class or interface in java.lang">java.lang.Enum</A>&lt;<A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A>&gt;
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.xuggle.ferry.JNIMemoryManager.MemoryModel</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Comparable.html" title="class or interface in java.lang">Comparable</A>&lt;<A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A>&gt;</DD>
</DL>
<DL>
<DT><B>Enclosing class:</B><DD><A HREF="JNIMemoryManager.html" title="class in com.xuggle.ferry">JNIMemoryManager</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public static enum <B>JNIMemoryManager.MemoryModel</B><DT>extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html" title="class or interface in java.lang">Enum</A>&lt;<A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A>&gt;</DL>
</PRE>

<P>
The different types of native memory allocation models Ferry supports. <h2>
 Memory Model Performance Implications</h2> Choosing the <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry"><CODE>JNIMemoryManager.MemoryModel</CODE></A>
 you use in Ferry libraries can have a big effect. Some models emphasize
 code that will work "as you expect" (Robustness), but sacrifice some
 execution speed to make that happen. Other models value speed first, and
 assume you know what you're doing and can manage your own memory.
 <p>
 In our experience the set of people who need robust software is larger than
 the set of people who need the (small) speed price paid, and so we default
 to the most robust model.
 </p>
 <p>
 Also in our experience, the set of people who really should just use the
 robust model, but instead think they need speed is much larger than the set
 of people who actually know what they're doing with java memory management,
 so please, <strong>we strongly recommend you start with a robust model and
 only change the <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry"><CODE>JNIMemoryManager.MemoryModel</CODE></A> if your performance testing shows you
 need speed.</strong> Don't say we didn't warn you.
 </p>
 
 <table>
 <tr>
 <th>Model</th>
 <th>Robustness</th>
 <th>Speed</th>
 </tr>
 
 <tr>
 <td> <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> (default)</td>
 <td>+++++</td>
 <td>+</td>
 </tr>
 
 <tr>
 <td> <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A></td>
 <td>+++</td>
 <td>++</td>
 </tr>
 
 <tr>
 <td> <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A></td>
 <td>+++</td>
 <td>+++</td>
 </tr>
 
 <tr>
 <td> <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS"><CODE>JAVA_DIRECT_BUFFERS</CODE></A> (not recommended)</td>
 <td>+</td>
 <td>++++</td>
 </tr>
 
 <tr>
 <td> <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS"><CODE>NATIVE_BUFFERS</CODE></A></td>
 <td>+</td>
 <td>+++++</td>
 </tr>
 
 </table>
 <h2>What is &quot;Robustness&quot;?</h2>
 <p>
 Ferry objects have to allocate native memory to do their job -- it's the
 reason for Ferry's existence. And native memory management is very
 different than Java memory management (for example, native C++ code doesn't
 have a garbage collector). To make things easier for our Java friends,
 Ferry tries to make Ferry objects look like Java objects.
 </p>
 <p>
 Which leads us to robustness. The more of these criteria we can hit with a
 <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry"><CODE>JNIMemoryManager.MemoryModel</CODE></A> the more robust it is.
 </p>
 <ol>
 
 <li><strong>Allocation</strong>: Calls to <code>make()</code> must
 correctly allocate memory that can be accessed from native or Java code and
 calls to <code>delete()</code> must release that memory immediately.</li>
 
 <li><strong>Collection</strong>: Objects no longer referenced in Java
 should have their underlying native memory released in a timely fashion.</li>
 
 <li><strong>Low Memory</strong>: New allocation in low memory conditions
 should first have the Java garbage collector release any old objects.</li>
 
 </ol>
 <h2>What is &quot;Speed&quot;?</h2>
 <p>
 Speed is how fast code executes under normal operating conditions. This is
 more subjective than it sounds, as how do you define normal operation
 conditions? But in general, we define it as &quot;generally plenty of heap
 space available&quot;
 </p>
 
 <h2>How Does JNIMemoryManager Work?</h2>
 <p>
 Every object that is exposed from native code inherits from
 <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A>.
 </p>
 <p>
 Ferry works by implementing a reference-counted memory management scheme
 in native code that is then manipulated from Java so you don't have to
 (usually) think about when to release native memory. Every time an object
 is created in native memory it has its reference count incremented by one;
 and everywhere inside the code we take care to release a reference when
 we're done.
 </p>
 <p>
 This maps nicely to the Java model of memory management, but with the
 benefit that Java does all the releasing behind the scenes. When you pass
 an object from Native code to Java, Ferry makes sure it has a reference
 count incremented, and then when the Java Virtual Machine collects the
 instance, Ferry automatically decrements the reference it in native code.
 </p>
 <p>
 In fact, in theory all you need to do is make a finalize() method on the
 Java object that decrements the reference count in the native code and
 everyone goes home happy.
 </p>
 <p>
 So far so good, but it brings up a big problem:
 <ul>
 <li>
 Turns out that video, audio and packets can be fairly large objects. For
 example, a 640x480 YUV420P decoded video frame object will take up around
 500K of memory. If those are allocated from native code, Java has no idea
 it got allocated; in fact the corresponding Java object will seem to only
 take up a few bytes of memory. Keep enough video frames around, and your
 Java process (that you expect to run in 64 Megs of heap memory) starts to
 consume large amounts of native memory. Not good.</li>
 <li>
 The Java virtual machine only collects garbage when it thinks it needs the
 space. However, because native code allocated the large chunks of memory,
 Java doesn't know that memory is being used. So it doesn't collect unused
 references, which if Ferry just used "finalize()" would mean that lots of
 unused memory might exist that clog up your system.</li>
 <li>
 Lastly, even if Java does do a garbage collection, it must make sure that
 all methods that have a finalize() method are first collected and put in a
 "safe-area" that awaits a second collection. On the second collection call,
 it starts calling finalize() on all those objects, but (don't ask why just
 trust us) if needs to dedicate a separate finalizer thread to this process.
 The result of this is if you allocate a lot of objects quickly, the
 finalizer thread can start to fall very far behind.</li>
 </ul>
 Now, aren't you sorry you asked. Here's the good news; The
 <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> implementation solves all these
 problems for you.
 <p>
 How you ask:
 </p>
 <ul>
 <li>
 We use Java Weak References to determine if a native object is no longer
 used in Java. Ferry objects allocated from native code do not finalizers.
 </li>
 <li>
 Then every-time you create a new Ferry object, we first make sure we do a
 mini-collection of all unused Ferry objects and release that native
 memory.</li>
 <li>
 Then, each Ferry object also maintains a reference to another object that
 DOES have a finalize() method and the only thing that method does is make
 sure another mini-collection is done. That way we can make sure memory is
 freed even if you never do another Ferry allocation.</li>
 <li>
 Lastly, we make sure that whenever we need large chunks of memory (for
 IPacket, IFrame and IAudioSamples interfaces) we can allocate those objects
 from Java, so Java ALWAYS knows just how much memory it's using.</li>
 </ul>
 The end result: you usually don't need to worry. </p>
 <p>
 In the event you need to manage memory more expicitly, every Ferry object
 has a "copyReference()" method that will create a new Java object that
 points to the same underlying native object.
 <p>
 And In the unlikely event you want to control EXACTLY when a native object
 is released, each Ferry object has a <A HREF="RefCounted.html#delete()"><CODE>RefCounted.delete()</CODE></A> method
 that you can use. Once you call "delete()", you must ENSURE your object is
 never referenced again from that Java object -- Ferry tries to help you
 avoid crashes if you accidentally use an object after deletion but on this
 but we cannot offer 100% protection (specifically if another thread is
 accessing that object EXACTLY when you <A HREF="RefCounted.html#delete()"><CODE>RefCounted.delete()</CODE></A> it). If
 you don't call <A HREF="RefCounted.html#delete()"><CODE>RefCounted.delete()</CODE></A>, we will call it at some point
 in the future, but you can't depend on when (and depending on the
 <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry"><CODE>JNIMemoryManager.MemoryModel</CODE></A> you are using, we may not be able to do it promptly).
 </p>
 <h2>What does all of this mean?</h2>
 <p>
 Well, it means if you're first writing code, don't worry about this. If
 you're instead trying to optimize for performance, first measure where your
 problems are, and if fingers are pointing at allocation in Ferry then start
 trying different models.
 </p>
 <p>
 But before you switch models, be sure to read the caveats and restrictions
 on each of the non <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> models, and make sure you
 have a good understanding of how <a
 href="http://java.sun.com/docs/hotspot/gc5.0/gc_tuning_5.html"> Java
 Garbage Collection</a> works.
 </p>
<P>

<P>
<HR>

<P>
<!-- =========== ENUM CONSTANT SUMMARY =========== -->

<A NAME="enum_constant_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Enum Constant Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS">JAVA_DIRECT_BUFFERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Large memory blocks are allocated as Direct <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio"><CODE>ByteBuffer</CODE></A> objects
 (as returned from <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html#allocateDirect(int)" title="class or interface in java.nio"><CODE>ByteBuffer.allocateDirect(int)</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION">JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Large memory blocks are allocated as Direct <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio"><CODE>ByteBuffer</CODE></A> objects
 (as returned from <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html#allocateDirect(int)" title="class or interface in java.nio"><CODE>ByteBuffer.allocateDirect(int)</CODE></A>), but the Java
 standard-heap is <i>informed</i> of the allocation by also attempting to
 quickly allocate (and release) a buffer of the same size on the standard
 heap..</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP">JAVA_STANDARD_HEAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Large memory blocks are allocated in Java byte[] arrays, and passed back
 into native code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS">NATIVE_BUFFERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Large memory blocks are allocated in native memory, completely bypassing
 the Java heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION">NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Large memory blocks are allocated in native memory, completely bypassing
 the Java heap, but Java is <i>informed</i> of the allocation by briefly
 creating (and immediately releasing) a Java standard heap byte[] array of
 the same size.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#getNativeValue()">getNativeValue</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the native value to pass to native code</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#valueOf(java.lang.String)">valueOf</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the enum constant of this type with the specified name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="JNIMemoryManager.MemoryModel.html#values()">values</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array containing the constants of this enum type, in
the order they're declared.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Enum"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html" title="class or interface in java.lang">Enum</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#compareTo(E)" title="class or interface in java.lang">compareTo</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#getDeclaringClass()" title="class or interface in java.lang">getDeclaringClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#name()" title="class or interface in java.lang">name</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#ordinal()" title="class or interface in java.lang">ordinal</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Enum.html#valueOf(java.lang.Class, java.lang.String)" title="class or interface in java.lang">valueOf</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ ENUM CONSTANT DETAIL =========== -->

<A NAME="enum_constant_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Enum Constant Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JAVA_STANDARD_HEAP"><!-- --></A><H3>
JAVA_STANDARD_HEAP</H3>
<PRE>
public static final <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A> <B>JAVA_STANDARD_HEAP</B></PRE>
<DL>
<DD><p>
 Large memory blocks are allocated in Java byte[] arrays, and passed back
 into native code. Releasing of underlying native resources happens behind
 the scenes with no management required on the programmer's part.
 </p>
 </p> <h2>Speed</h2>
 <p>
 This is the slowest model available.
 </p>
 <p>
 The main decrease in speed occurs for medium-life-span objects. Short
 life-span objects (objects that die during the life-span of an
 incremental collection) are relatively efficient. Once an object makes it
 into the Tenured generation in Java, then unnecessary copying stops until
 the next full collection.
 </p>
 <p>
 However while in the Eden generation but surviving between incremental
 collections, large native buffers may get copied many times
 unnecessarily. This copying can have a significant performance impact.
 </p>
 <h2>Robustness</h2>
 <ol>
 
 <li><strong>Allocation</strong>: Works as expected.</li>
 
 <li><strong>Collection</strong>: Released either when
 <code>delete()</code> is called, the item is marked for collection, or
 we're in Low Memory conditions and the item is unused.</li>
 
 <li><strong>Low Memory</strong>: Very strong. In this model Java always
 knows exactly how much native heap space is being used, and can trigger
 collections at the right time.</li>
 
 </ol>
 
 <h2>Tuning Tips</h2>
 <p>
 When using this model, these tips may increase performance, although in
 some situations, may instead decrease your performance. Always measure.
 </p>
 <ul>
 <li>Try different garbage collectors in Java. To try the parallel
 incremental collector, start your Java process with: these options:
 
 <pre>
 -XX:+UseParallelGC
 </pre>
 
 The concurrent garbage collector works well too. To use that pass these
 options to java on startup:
 
 <pre>
 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
 </pre>
 
 </li>
 <li>If you are not re-using objects across Ferry calls, ensure your
 objects are short-lived; null out references when done.</li>
 <li>Potentially try caching objects and reusing large objects across
 multiple calls -- this may give those objects time to move into the
 Tenured generation and reduce the copying overhead.</li>
 <li>Explicitly manage Ferry memory yourself by calling
 <code>delete()</code> on every <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object when done with
 your objects to let Java know it doesn't need to copy the item across a
 collection. You can also use <code>copyReference()</code> to get a new
 Java version of the same Ferry object that you can pass to another thread
 if you don't know when <code>delete()</code> can be safely called.</li>
 
 <li>Try a different <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry"><CODE>JNIMemoryManager.MemoryModel</CODE></A>.</li>
 </ul>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="JAVA_DIRECT_BUFFERS"><!-- --></A><H3>
JAVA_DIRECT_BUFFERS</H3>
<PRE>
public static final <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A> <B>JAVA_DIRECT_BUFFERS</B></PRE>
<DL>
<DD>Large memory blocks are allocated as Direct <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio"><CODE>ByteBuffer</CODE></A> objects
 (as returned from <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html#allocateDirect(int)" title="class or interface in java.nio"><CODE>ByteBuffer.allocateDirect(int)</CODE></A>).
 <p>
 This model is not recommended. It is faster than
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A>, but because of how Sun implements direct
 buffers, it works poorly in low memory conditions. This model has all the
 caveats of the <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS"><CODE>NATIVE_BUFFERS</CODE></A> model, but allocation is slightly
 slower.
 </p>
 <h2>Speed</h2>
 <p>
 This is the 2nd fastest model available. In tests it is generally 20-30%
 faster than the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 
 </p>
 <p>
 It is using Java to allocate direct memory, which is slightly slower than
 using <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS"><CODE>NATIVE_BUFFERS</CODE></A>, but much faster than using the
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 <p>
 The downside is that for high-performance applications, you may need to
 explicitly manage <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object life-cycles with
 <A HREF="RefCounted.html#delete()"><CODE>RefCounted.delete()</CODE></A> to ensure direct memory is released in a
 timely manner.
 </p>
 <h2>Robustness</h2>
 <ol>
 
 <li><strong>Allocation</strong>: Weak. Java controls allocations of
 direct memory from a separate heap (yet another one), and has an
 additional tuning option to set that. By default on most JVMs, this heap
 size is set to 64mb which is very low for video processing (queue up 100
 images and see what we mean).</li>
 
 <li><strong>Collection</strong>: Released either when
 <code>delete()</code> is called, or when the item is marked for
 collection</li>
 
 <li><strong>Low Memory</strong>: Weak. In this model Java knows how much
 <strong>direct</strong> memory it has allocated, but it does not use the
 size of the Direct Heap to influence when it collects the normal
 non-direct Java Heap -- and our allocation scheme depends on normal Java
 Heap collection. Therefore it can fail to run collections in a timely
 manner because it thinks the standard heap has plenty of space to grow.
 This may cause failures.</li>
 
 </ol>
 
 <h2>Tuning Tips</h2>
 <p>
 When using this model, these tips may increase performance, although in
 some situations, may instead decrease performance. Always measure.
 </p>
 <ul>
 <li>Increase the size of Sun's Java's direct buffer heap. Sun's Java
 implementation has an artificially low default separate heap for direct
 buffers (64mb). To make it higher pass this option to Java at startup:
 
 <pre>
 -XX:MaxDirectMemorySize=&lt;size&gt;
 </pre>
 
 </li>
 <li>Paradoxically, try decreasing the size of your Java Heap if you get
 <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> exceptions. Objects that are allocated in native
 memory have a small proxy object representing them in the Java Heap. By
 decreasing your heap size, those proxy objects will exert more collection
 pressure, and hopefully cause Java to do incremental collections more
 often (and notice your unused objects). To set the maximum size of your
 java heap, pass this option to java on startup:
 
 <pre>
 -Xmx&lt;size&gt;
 </pre>
 
 To change the minimum size of your java heap, pass this option to java on
 startup:
 
 <pre>
 -Xms&lt;size&gt;
 </pre>
 
 </li>
 <li>
 <li>Try different garbage collectors in Java. To try the parallel
 incremental collector, start your Java process with: these options:
 
 <pre>
 -XX:+UseParallelGC
 </pre>
 
 The concurrent garbage collector works well too. To use that pass these
 options to java on startup:
 
 <pre>
 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
 </pre>
 
 </li>
 <li>If you are not re-using objects across Ferry calls, ensure your
 objects are short-lived; null out references when done.</li>
 <li>Potentially try caching objects and reusing large objects across
 multiple calls -- this may give those objects time to move into the
 Tenured generation and reduce the copying overhead.</li>
 <li>Explicitly manage Ferry memory yourself by calling
 <code>delete()</code> on every <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object when done with
 your objects to let Java know it doesn't need to copy the item across a
 collection. You can also use <code>copyReference()</code> to get a new
 Java version of the same Ferry object that you can pass to another thread
 if you don't know when <code>delete()</code> can be safely called.</li>
 
 <li>Try the
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A>
 model.</li>
 
 </ul>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><!-- --></A><H3>
JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</H3>
<PRE>
public static final <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A> <B>JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</B></PRE>
<DL>
<DD>Large memory blocks are allocated as Direct <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio"><CODE>ByteBuffer</CODE></A> objects
 (as returned from <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/nio/ByteBuffer.html#allocateDirect(int)" title="class or interface in java.nio"><CODE>ByteBuffer.allocateDirect(int)</CODE></A>), but the Java
 standard-heap is <i>informed</i> of the allocation by also attempting to
 quickly allocate (and release) a buffer of the same size on the standard
 heap..
 <p>
 This model can work well if your application is mostly single-threaded,
 and your Ferry application is doing most of the memory allocation in your
 program. The trick of <i>informing</i> Java will put pressure on the JVM
 to collect appropriately, but by not keeping the references we avoid
 unnecessary copying for objects that survive collections.
 </p>
 <p>
 This heuristic is not failsafe though, and can still lead to collections
 not occurring at the right time for some applications.
 </p>
 <p>
 It is similar to the
 <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A> model and in
 general we recommend that model over this one.
 </p>
 <h2>Speed</h2>
 <p>
 This model trades off some robustness for some speed. In tests it is
 generally 10-20% faster than the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 <p>
 It is worth testing as a way of avoiding the explicit memory management
 needed to effectively use the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS"><CODE>JAVA_DIRECT_BUFFERS</CODE></A> model.
 However, the heuristic used is not fool-proof, and therefore may
 sometimes lead to unnecessary collection or <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A>
 because Java didn't collect unused references in the standard heap in
 time (and hence did not release underlying native references).
 </p>
 <h2>Robustness</h2>
 <ol>
 
 <li><strong>Allocation</strong>: Good. Java controls allocations of
 direct memory from a separate heap (yet another one), and has an
 additional tuning option to set that. By default on most JVMs, this heap
 size is set to 64mb which is very low for video processing (queue up 100
 images and see what we mean). With this option though we <i>inform</i>
 Java of the allocation in the Direct heap, and this will often encourage
 Java to collect memory on a more timely basis.</li>
 
 <li><strong>Collection</strong>: Good. Released either when
 <code>delete()</code> is called, or when the item is marked for
 collection. Collections happen more frequently than under the
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS"><CODE>JAVA_DIRECT_BUFFERS</CODE></A> model due to <i>informing</i> the standard
 heap at allocation time.</li>
 
 <li><strong>Low Memory</strong>: Good. Especially for mostly
 single-threaded applications, the collection pressure introduced on
 allocation will lead to more timely collections to avoid
 <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> errors on the Direct heap.</li>
 </ol>
 
 <h2>Tuning Tips</h2>
 <p>
 When using this model, these tips may increase performance, although in
 some situations, may instead decrease performance. Always measure.
 </p>
 <ul>
 <li>Increase the size of Sun's Java's direct buffer heap. Sun's Java
 implementation has an artificially low default separate heap for direct
 buffers (64mb). To make it higher pass this option to Java at startup:
 
 <pre>
 -XX:MaxDirectMemorySize=&lt;size&gt;
 </pre>
 
 </li>
 <li>Paradoxically, try decreasing the size of your Java Heap if you get
 <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> exceptions. Objects that are allocated in native
 memory have a small proxy object representing them in the Java Heap. By
 decreasing your heap size, those proxy objects will exert more collection
 pressure, and hopefully cause Java to do incremental collections more
 often (and notice your unused objects). To set the maximum size of your
 java heap, pass this option to java on startup:
 
 <pre>
 -Xmx&lt;size&gt;
 </pre>
 
 To change the minimum size of your java heap, pass this option to java on
 startup:
 
 <pre>
 -Xms&lt;size&gt;
 </pre>
 
 </li>
 <li>
 <li>Try different garbage collectors in Java. To try the parallel
 incremental collector, start your Java process with: these options:
 
 <pre>
 -XX:+UseParallelGC
 </pre>
 
 The concurrent garbage collector works well too. To use that pass these
 options to java on startup:
 
 <pre>
 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
 </pre>
 
 </li>
 <li>If you are not re-using objects across Ferry calls, ensure your
 objects are short-lived; null out references when done.</li>
 <li>Potentially try caching objects and reusing large objects across
 multiple calls -- this may give those objects time to move into the
 Tenured generation and reduce the copying overhead.</li>
 <li>Explicitly manage Ferry memory yourself by calling
 <code>delete()</code> on every <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object when done with
 your objects to let Java know it doesn't need to copy the item across a
 collection. You can also use <code>copyReference()</code> to get a new
 Java version of the same Ferry object that you can pass to another thread
 if you don't know when <code>delete()</code> can be safely called.</li>
 
 <li>Try the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.</li>
 
 </ul>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="NATIVE_BUFFERS"><!-- --></A><H3>
NATIVE_BUFFERS</H3>
<PRE>
public static final <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A> <B>NATIVE_BUFFERS</B></PRE>
<DL>
<DD>Large memory blocks are allocated in native memory, completely bypassing
 the Java heap.
 <p>
 It is <strong>much</strong> faster than the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A>,
 but much less robust.
 </p>
 <h2>Speed</h2>
 <p>
 This is the fastest model available. In tests it is generally 30-40%
 faster than the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 
 </p>
 <p>
 It is using the native operating system to allocate direct memory, which
 is slightly faster than using <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS"><CODE>JAVA_DIRECT_BUFFERS</CODE></A>, and much
 faster than using the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 <p>
 The downside is that for high-performance applications, you may need to
 explicitly manage <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object life-cycles with
 <A HREF="RefCounted.html#delete()"><CODE>RefCounted.delete()</CODE></A> to ensure native memory is released in a
 timely manner.
 </p>
 <h2>Robustness</h2>
 <ol>
 
 <li><strong>Allocation</strong>: Weak. Allocations using
 <code>make</code> and releasing objects with <A HREF="RefCounted.html#delete()"><CODE>RefCounted.delete()</CODE></A>
 works like normal, but because Java has no idea of how much space is
 actually allocated in native memory, it may not collect
 <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> objects as quickly as you need it to (it will
 eventually collect and free all references though).</li>
 
 <li><strong>Collection</strong>: Released either when
 <code>delete()</code> is called, or when the item is marked for
 collection</li>
 
 <li><strong>Low Memory</strong>: Weak. In this model Java has no idea how
 much native memory is allocated, and therefore does not use that
 knowledge in its determination of when to collect. This can lead to
 <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> objects you created surviving longer than you want to,
 and therefore not releasing native memory in a timely fashion.</li>
 </ol>
 
 <h2>Tuning Tips</h2>
 <p>
 When using this model, these tips may increase performance, although in
 some situations, may instead decrease performance. Always measure.
 </p>
 <ul>
 <li>Paradoxically, try decreasing the size of your Java Heap if you get
 <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> exceptions. Objects that are allocated in native
 memory have a small proxy object representing them in the Java Heap. By
 decreasing your heap size, those proxy objects will exert more collection
 pressure, and hopefully cause Java to do incremental collections more
 often (and notice your unused objects). To set the maximum size of your
 java heap, pass this option to java on startup:
 
 <pre>
 -Xmx&lt;size&gt;
 </pre>
 
 To change the minimum size of your java heap, pass this option to java on
 startup:
 
 <pre>
 -Xms&lt;size&gt;
 </pre>
 
 </li>
 <li>
 <li>Try different garbage collectors in Java. To try the parallel
 incremental collector, start your Java process with: these options:
 
 <pre>
 -XX:+UseParallelGC
 </pre>
 
 The concurrent garbage collector works well too. To use that pass these
 options to java on startup:
 
 <pre>
 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
 </pre>
 
 </li>
 <li>Use the <A HREF="JNIMemoryManager.html#startCollectionThread()"><CODE>JNIMemoryManager.startCollectionThread()</CODE></A> method to
 start up a thread dedicated to releasing objects as soon as they are
 enqued in a <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ref/ReferenceQueue.html" title="class or interface in java.lang.ref"><CODE>ReferenceQueue</CODE></A>, rather than (the default) waiting for
 the next Ferry allocation or <A HREF="JNIMemoryManager.html#collect()"><CODE>JNIMemoryManager.collect()</CODE></A> explicit
 call. Or periodically call <A HREF="JNIMemoryManager.html#collect()"><CODE>JNIMemoryManager.collect()</CODE></A> yourself.</li>
 <li>Cache long lived objects and reuse them across calls to avoid
 allocations.</li>
 <li>Explicitly manage Ferry memory yourself by calling
 <code>delete()</code> on every <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object when done with
 your objects to let Java know it doesn't need to copy the item across a
 collection. You can also use <code>copyReference()</code> to get a new
 Java version of the same Ferry object that you can pass to another thread
 if you don't know when <code>delete()</code> can be safely called.</li>
 
 <li>Try the
 <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A> model.
 </li>
 
 </ul>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><!-- --></A><H3>
NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</H3>
<PRE>
public static final <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A> <B>NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</B></PRE>
<DL>
<DD>Large memory blocks are allocated in native memory, completely bypassing
 the Java heap, but Java is <i>informed</i> of the allocation by briefly
 creating (and immediately releasing) a Java standard heap byte[] array of
 the same size.
 <p>
 It is faster than the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A>, but less robust.
 </p>
 <p>
 This model can work well if your application is mostly single-threaded,
 and your Ferry application is doing most of the memory allocation in your
 program. The trick of informing Java will put pressure on the JVM to
 collect appropriately, but by not keeping the references to the byte[]
 array we temporarily allocate, we avoid unnecessary copying for objects
 that survive collections.
 </p>
 <p>
 This heuristic is not failsafe though, and can still lead to collections
 not occurring at the right time for some applications.
 </p>
 <p>
 It is similar to the
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A> model.
 </p>
 <h2>Speed</h2>
 <p>
 In tests this model is generally 25-30% faster than the
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 </p>
 <p>
 It is using the native operating system to allocate direct memory, which
 is slightly faster than using
 <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>JAVA_DIRECT_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A>, and much
 faster than using the <A HREF="JNIMemoryManager.MemoryModel.html#JAVA_STANDARD_HEAP"><CODE>JAVA_STANDARD_HEAP</CODE></A> model.
 </p>
 <p>
 It is worth testing as a way of avoiding the explicit memory management
 needed to effectively use the <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS"><CODE>NATIVE_BUFFERS</CODE></A> model. However, the
 heuristic used is not fool-proof, and therefore may sometimes lead to
 unnecessary collection or <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> because Java didn't
 collect unused references in the standard heap in time (and hence did not
 release underlying native references).
 </p>
 <h2>Robustness</h2>
 <ol>
 
 <li><strong>Allocation</strong>: Good. With this option we allocate
 large, long-lived memory from the native heap, but we <i>inform</i> Java
 of the allocation in the Direct heap, and this will often encourage Java
 to collect memory on a more timely basis.</li>
 
 <li><strong>Collection</strong>: Good. Released either when
 <code>delete()</code> is called, or when the item is marked for
 collection. Collections happen more frequently than under the
 <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS"><CODE>NATIVE_BUFFERS</CODE></A> model due to <i>informing</i> the standard heap
 at allocation time.</li>
 
 <li><strong>Low Memory</strong>: Good. Especially for mostly
 single-threaded applications, the collection pressure introduced on
 allocation will lead to more timely collections to avoid
 <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> errors on the native heap.</li>
 </ol>
 
 <h2>Tuning Tips</h2>
 <p>
 When using this model, these tips may increase performance, although in
 some situations, may instead decrease performance. Always measure.
 </p>
 <ul>
 <li>Paradoxically, try decreasing the size of your Java Heap if you get
 <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/OutOfMemoryError.html" title="class or interface in java.lang"><CODE>OutOfMemoryError</CODE></A> exceptions. Objects that are allocated in native
 memory have a small proxy object representing them in the Java Heap. By
 decreasing your heap size, those proxy objects will exert more collection
 pressure, and hopefully cause Java to do incremental collections more
 often (and notice your unused objects). To set the maximum size of your
 java heap, pass this option to java on startup:
 
 <pre>
 -Xmx&lt;size&gt;
 </pre>
 
 To change the minimum size of your java heap, pass this option to java on
 startup:
 
 <pre>
 -Xms&lt;size&gt;
 </pre>
 
 </li>
 <li>
 <li>Try different garbage collectors in Java. To try the parallel
 incremental collector, start your Java process with: these options:
 
 <pre>
 -XX:+UseParallelGC
 </pre>
 
 The concurrent garbage collector works well too. To use that pass these
 options to java on startup:
 
 <pre>
 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
 </pre>
 
 </li>
 <li>Use the <A HREF="JNIMemoryManager.html#startCollectionThread()"><CODE>JNIMemoryManager.startCollectionThread()</CODE></A> method to
 start up a thread dedicated to releasing objects as soon as they are
 enqued in a <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ref/ReferenceQueue.html" title="class or interface in java.lang.ref"><CODE>ReferenceQueue</CODE></A>, rather than (the default) waiting for
 the next Ferry allocation or <A HREF="JNIMemoryManager.html#collect()"><CODE>JNIMemoryManager.collect()</CODE></A> explicit
 call. Or periodically call <A HREF="JNIMemoryManager.html#collect()"><CODE>JNIMemoryManager.collect()</CODE></A> yourself.</li>
 <li>Cache long lived objects and reuse them across calls to avoid
 allocations.</li>
 <li>Explicitly manage Ferry memory yourself by calling
 <code>delete()</code> on every <A HREF="RefCounted.html" title="class in com.xuggle.ferry"><CODE>RefCounted</CODE></A> object when done with
 your objects to let Java know it doesn't need to copy the item across a
 collection. You can also use <code>copyReference()</code> to get a new
 Java version of the same Ferry object that you can pass to another thread
 if you don't know when <code>delete()</code> can be safely called.</li>
 
 <li>Try the
 <A HREF="JNIMemoryManager.MemoryModel.html#NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION"><CODE>NATIVE_BUFFERS_WITH_STANDARD_HEAP_NOTIFICATION</CODE></A> model.
 </li>
 
 </ul>
<P>
<DL>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="values()"><!-- --></A><H3>
values</H3>
<PRE>
public static final <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A>[] <B>values</B>()</PRE>
<DL>
<DD>Returns an array containing the constants of this enum type, in
the order they're declared.  This method may be used to iterate
over the constants as follows:
<pre>
for(JNIMemoryManager.MemoryModel c : JNIMemoryManager.MemoryModel.values())
        System.out.println(c);
</pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an array containing the constants of this enum type, in
the order they're declared</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.String)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static <A HREF="JNIMemoryManager.MemoryModel.html" title="enum in com.xuggle.ferry">JNIMemoryManager.MemoryModel</A> <B>valueOf</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html" title="class or interface in java.lang">String</A>&nbsp;name)</PRE>
<DL>
<DD>Returns the enum constant of this type with the specified name.
The string must match <I>exactly</I> an identifier used to declare an
enum constant in this type.  (Extraneous whitespace characters are 
not permitted.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the name of the enum constant to be returned.
<DT><B>Returns:</B><DD>the enum constant with the specified name
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if this enum type has no constant
with the specified name</DL>
</DD>
</DL>
<HR>

<A NAME="getNativeValue()"><!-- --></A><H3>
getNativeValue</H3>
<PRE>
public int <B>getNativeValue</B>()</PRE>
<DL>
<DD>Get the native value to pass to native code
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a value.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JNIMemoryManager.MemoryModel.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="JNIMemoryManager.html" title="class in com.xuggle.ferry"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="JNINativeFinalizer.html" title="class in com.xuggle.ferry"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index7d63.html?com/xuggle/ferry/JNIMemoryManager.MemoryModel.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JNIMemoryManager.MemoryModel.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#enum_constant_summary">ENUM CONSTANTS</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#enum_constant_detail">ENUM CONSTANTS</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008, 2010 <a href="http://www.xuggle.com/" target="_blank">Xuggle</a></i>
</BODY>

<!-- Mirrored from www.xuggle.com/public/documentation/java/api/com/xuggle/ferry/JNIMemoryManager.MemoryModel.html by HTTrack Website Copier/3.x [XR&CO'2010], Fri, 14 Jun 2013 14:00:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
</HTML>
